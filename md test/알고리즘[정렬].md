알고리즘

정렬 - 알고리즘 효율성 많이 영향, 빅오는 다 n*2 이다.

오름차순. 

1. 선택 정렬
   가장 작은 것을 선택해서 앞으로 보내면 어떨까?

   ```c
   // 선택정렬은 가장 작은 거 선택해서 본 범위의 왼쪽 끝 숫자랑 스왑.
   // 반복할수록 범위가 하나씩 줄어들겠지.
   // 41523 -> 14523 -> 12543 -> 12345
   #include <stdio.h>
   void selectionSort(int* arr, int arrSize)
   {
      int min; // 가장 작은 데이터를 담을 거
      int min_index = 0; // 주어진 배열에서 범위 내 가장 작은 값의 위치.
      int temp; // 스왑할 떄 데이터를 담은 공간.
      // 반복(1)작은거 찾기 -> 범위의 왼쪽 값과 스왑 -> 반복(2)다음 범위로 반복

      for (size_t i = 0; i < arrSize; i++)
      {
         min = 9999;
         for (size_t j = i; j < arrSize; j++)
         {
            if (arr[j] < min)
            {
                  min = arr[j];
                  min_index = j;
            }
         }
         temp = arr[i];
         arr[i] = min;
         arr[min_index] = temp;
      }
   }
   int main()
   {
      int arr[] = {1,10,5,8,7,6,4,3,2,9};
      selectionSort(arr, 10);
      for (size_t i = 0; i < 10; i++)
      {
         printf("%d", arr[i]);
         printf("\n");
      }
      
      return 0;
   }
   ```
   1, 10, 5, 8, 7, 6, 4, 3, 2, 9

   빅오 - 총 연산횟수.

   n*2 - 비효율적

2. 버블 정렬
   옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까? -> 반복할때마다 가장 큰 값이 맨 뒤로 간다.
   구현이 가장 쉬운데 가장 비효율적

   ```c
   
   ```

   빅오 - n * 2 

   실제 수행 시간은 버블이 선택보다 느리다. / 자리를 바꾸는 연산이 더 많아서 더 느리게 작동한다.

3. 삽입 정렬
   버블, 선택은 무조건 위치를 바꾸지만 삽입은 필요할 때만 위치를 바꾼다.
   반복되기 전 상태는 다 정렬되어 있다 가정하기 때문에 빠르게 작동할 수 있다.
   값이 가장 작은 위치까지 이동.

   ```c
   
   ```

   시간 복잡도는 똑같지만 특정 경우에는 굉장히 빠르게 동작한다.
   거의 정렬된 상태에서 사용될 때 굉장히 효율적이다.

4. 퀵 정렬
   대표적인 빠른 정렬 알고리즘. 분할 정복 하는 알고리즘이다. 
   빅오는 n * logn
   피벗 값이 있다. - 기준값
   기준값 보다 큰 값과 작은 값을 ㅇ찾아서 위치 스왑.
   재귀이용.
   하지만 최악 시간 복잡도는 n * 2 이다.
   이미 정렬이 되어 있는 경우에는 분할 정복의 이점을 살릴 필요가 없기 때문이다.

5. 